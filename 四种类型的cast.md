## C++ 四种类型的cast

#### 1. `reinterpret_cast`

`reinterpre_cast`主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转换为指针呢或引用类型。

#### 2. `static_cast`

允许执行任意的隐式转换和相反的转换动作，即它允许将子类指针转换为父类指针，也允许将父类指针转换为子类指针。

与C语言的类型转换基本相同，由于没有类型检查，所以向下转换是不安全的。

#### 3. `dynamic_cast`

`dynamic_cast`是唯一一个在运行期进行的类型转换，主要是因为其具有类型检查功能。

`dynamic_cast`只用于对象的指针和引用。当用于多态类型时，在进行隐式转换的相反过程时（即将父类转换为子类），`dynamic_cast`会检查转换是否有效。如果无效，会返回一个NULL指针。

那么什么是无效的情况呢？

比如下面这两种：

```c++
Base* b1 = new Derived();
Base* b2 = new Base();
```

两种都是Base类型指针，但一个是Derived类型实例，这个可以转换成功，后一种则不行。

也就是说转换后的指针类型与其指向的对象类型要保持一致才能转换成功。

此外，使用`dynamic_cast`时**必须要保证基类定义有虚函数**，否则编译不通过。因为编译器认为只有在有虚函数的情况下才会有必要将父类指针指向子类实例对象。

所以这个`dynamic_cast`使用的门槛还是挺高的。

#### 4. `const_cast`

前面三种都是用于类型转换，而`const_cast`用于const转换。

这种转换类型可以操纵对象的const属性，也是唯一一种可以将const属性移除的转换。

但是const常量定义出来一定是有道理的，不要随随便便就用这个把人家的const属性给去了，容易使程序出问题。